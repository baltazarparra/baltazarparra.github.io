{"componentChunkName":"component---src-templates-blog-post-js","path":"/alem-do-ES6/","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Além do ECMAScript 2015 aka ES6","resume":"ES7, ES8, ES9, ES10 e ES11. Vamos dar uma olhada nas funcionalidades implementadas após o ES6","date":"18 de Julho de 2021","tags":"tech"},"html":"<h3>ECMAScript 2016 / ES7</h3> <br>\n<p><br>JavaScript Exponentiation: <br>\n<small>É equivalente a Math.pow</small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">console.log(3 ** 4);\n// expected output: 81\n\nconsole.log(10 ** -2);\n// expected output: 0.01\n\nconsole.log(2 ** 3 ** 2);\n// expected output: 512\n\nconsole.log((2 ** 3) ** 2);\n// expected output: 64</code>\n        </deckgo-highlight-code>\n<p><br>JavaScript Exponentiation assignment <br>\n<small>O operador de atribuição de exponenciação (** =) eleva o valor de uma variável à potência do operando direito</small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">let a = 3;\n\nconsole.log(a **= 2);\n// expected output: 9\n\nconsole.log(a **= 0);\n// expected output: 1\n\nconsole.log(a **= &#39;hello&#39;);\n// expected output: NaN</code>\n        </deckgo-highlight-code>\n<p><br>JavaScript Array.prototype.includes <br>\n<small>O método includes() determina se um array contém um determinado elemento, retornando true ou false apropriadamente.</small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">[1, 2, 3].includes(2);     // true\n[1, 2, 3].includes(4);     // false\n[1, 2, 3].includes(3, 3);  // false\n[1, 2, 3].includes(3, -1); // true\n[1, 2, NaN].includes(NaN); // true</code>\n        </deckgo-highlight-code>\n<p><br><br></p>\n<h3>ECMAScript 2017 / ES8</h3> <br>\n<p><br>JavaScript String padding <br>\n<small>A string é preenchida até um determinado comprimento, que é passado para os métodos String.prototype .padStart () e .padEnd ()</small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const str1 = &#39;5&#39;;\n\nconsole.log(str1.padStart(2, &#39;0&#39;));\n// expected output: &quot;05&quot;\n\nconst fullNumber = &#39;2034399002125581&#39;;\nconst last4Digits = fullNumber.slice(-4);\nconst maskedNumber = last4Digits.padStart(fullNumber.length, &#39;*&#39;);\n\nconsole.log(maskedNumber);\n// expected output: &quot;************5581&quot;</code>\n        </deckgo-highlight-code>\n<p><br>JavaScript Object.entries <br>\n<small>O método Object.entries() retorna uma array dos próprios pares  [key, value] enumeráveis de um dado objeto, na mesma ordem dos objetos providos através do loop for...in (sendo a diferença que o for-in loop enumera também propriedades dispostas na cadeia de prototipagem - prototype chain) </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">var obj = { foo: &#39;bar&#39;, baz: 42 };\nconsole.log(Object.entries(obj)); // [ [&#39;foo&#39;, &#39;bar&#39;], [&#39;baz&#39;, 42] ]\n\n// objeto array-like\nvar obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39; };\nconsole.log(Object.entries(obj)); // [ [&#39;0&#39;, &#39;a&#39;], [&#39;1&#39;, &#39;b&#39;], [&#39;2&#39;, &#39;c&#39;] ]\n\n// objeto array-like com ordenação aleatória de chave (key)\nvar an_obj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; };\nconsole.log(Object.entries(an_obj)); // [ [&#39;2&#39;, &#39;b&#39;], [&#39;7&#39;, &#39;c&#39;], [&#39;100&#39;, &#39;a&#39;] ]\n\n// getFoo é uma propriedade que não é enumerável\nvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\nmy_obj.foo = &#39;bar&#39;;\nconsole.log(Object.entries(my_obj)); // [ [&#39;foo&#39;, &#39;bar&#39;] ]\n\n// argumento não-objeto será convertido (conversão implícita) para um objeto\nconsole.log(Object.entries(&#39;foo&#39;)); // [ [&#39;0&#39;, &#39;f&#39;], [&#39;1&#39;, &#39;o&#39;], [&#39;2&#39;, &#39;o&#39;] ]\n\n// itera graciosamente através de chave-valor (key-value)\nvar obj = {a: 5, b: 7, c: 9};\nfor (var [key, value] of Object.entries(obj)) {\n    console.log(key + &#39; &#39; + value); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;\n}\n\n// Ou, usando array extras\nObject.entries(obj).forEach(([key, value]) =&gt; {\n    console.log(key + &#39; &#39; + value); // &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;\n});</code>\n        </deckgo-highlight-code>\n<p><br>JavaScript Object.values <br>\n<small>O método Object.values() retorna um array com os valores das propriedades de um dado objeto, na mesma ordem provida pelo for...in laço (sendo a diferença que o laço for-in também enumera as propriedades na cadeia prototype).</small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">var obj = { foo: &quot;bar&quot;, baz: 42 };\nconsole.log(Object.values(obj)); // [&#39;bar&#39;, 42]\n\n// array como objeto\nvar obj = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39; };\nconsole.log(Object.values(obj)); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n// array como objeto com ordenação de chave aleatória\nvar an_obj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; };\nconsole.log(Object.values(an_obj)); // [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]\n\n// getFoo é a propriedade a qual não é enumerável\nvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\nmy_obj.foo = &quot;bar&quot;;\nconsole.log(Object.values(my_obj)); // [&#39;bar&#39;]\n\n// argumento não-objeto será coagido num objeto\nconsole.log(Object.values(&quot;foo&quot;)); // [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]</code>\n        </deckgo-highlight-code>\n<p><br>JavaScript async functions <br>\n<small>A declaração async function define uma função assíncrona, que retorna um objeto AsyncFunction.</p>\n<p>Você também pode definir funções assíncronas usando uma expressão async function </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function resolverDepoisDe2Segundos(x) {\n  return new Promise(resolve =&gt; {\n    setTimeout(() =&gt; {\n      resolve(x);\n    }, 2000);\n  });\n}\n\nasync function adicionar1(x) {\n  var a = resolverDepoisDe2Segundos(20);\n  var b = resolverDepoisDe2Segundos(30);\n  return x + await a + await b;\n}\n\nadicionar1(10).then(v =&gt; {\n  console.log(v);  // exibe 60 depois de 2 segundos.\n});\n\nasync function adicionar2(x) {\n  var a = await resolverDepoisDe2Segundos(20);\n  var b = await resolverDepoisDe2Segundos(30);\n  return x + a + b;\n}\n\nadicionar2(10).then(v =&gt; {\n  console.log(v);  // exibe 60 depois de 4 segundos.\n});</code>\n        </deckgo-highlight-code>\n<p><br><br></p>\n<h3>ECMAScript 2018 / ES9</h3> <br>\n<p><br>Asynchronous Iteration <br>\n<small>A iteração assíncrona nos permite iterar os dados que chegam de forma assíncrona, sob demanda. Como, por exemplo, quando baixamos algo pedaço a pedaço em uma rede. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">let range = {\n  from: 1,\n  to: 5,\n\n  [Symbol.asyncIterator]() { // (1)\n    return {\n      current: this.from,\n      last: this.to,\n\n      async next() { // (2)\n\n        // note: we can use &quot;await&quot; inside the async next:\n        await new Promise(resolve =&gt; setTimeout(resolve, 1000)); // (3)\n\n        if (this.current &lt;= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\n(async () =&gt; {\n\n  for await (let value of range) { // (4)\n    alert(value); // 1,2,3,4,5\n  }\n\n})()</code>\n        </deckgo-highlight-code>\n<p><br>Promise Finally <br>\n<small>O método finally() retorna uma Promise. Quando a promise for estabelecida, tenha ela sido realizada ou rejeitada, executa-se a função callback especificada. Isso permite a execução de um código que acontecerá independentemente da Promise ter sido realizada (com sucesso) ou rejeitada (com falha).</p>\n<p>Assim, você pode evitar a duplicação do código em ambos os handlers then() e catch() da Promise. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function checkMail() {\n  return new Promise((resolve, reject) =&gt; {\n    if (Math.random() &gt; 0.5) {\n      resolve(&#39;Mail has arrived&#39;);\n    } else {\n      reject(new Error(&#39;Failed to arrive&#39;));\n    }\n  });\n}\n\ncheckMail()\n  .then((mail) =&gt; {\n    console.log(mail);\n  })\n  .catch((err) =&gt; {\n    console.error(err);\n  })\n  .finally(() =&gt; {\n    console.log(&#39;Experiment completed&#39;);\n  });</code>\n        </deckgo-highlight-code>\n<p><br><br></p>\n <h3>ECMAScript 2019 / ES10</h3> <br>\n<p><br>Array.flat <br>\n<small>O método flat() cria um novo array com todos elementos sub-arrays concatenados nele de forma recursiva até a profundidade especificada. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const arr1 = [0, 1, 2, [3, 4]];\n\nconsole.log(arr1.flat());\n// expected output: [0, 1, 2, 3, 4]\n\nconst arr2 = [0, 1, 2, [[[3, 4]]]];\n\nconsole.log(arr2.flat(2));\n// expected output: [0, 1, 2, [3, 4]]</code>\n        </deckgo-highlight-code>\n<p><br>Array.flatMap <br>\n<small>O método flatMap() primeiro mapeia cada elemento usando uma função de mapeamento e, em seguida, nivela o resultado em um novo array. É idêntico a um map seguido por um flat de profundidade 1, mas flatMap é bastante útil e mescla ambos em um método um pouco mais eficiente. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">var arr1 = [1, 2, 3, 4];\n\narr1.map(x =&gt; [x * 2]);\n// [[2], [4], [6], [8]]\n\narr1.flatMap(x =&gt; [x * 2]);\n// [2, 4, 6, 8]\n\n//  Só o primeiro nível\narr1.flatMap(x =&gt; [[x * 2]]);\n// [[2], [4], [6], [8]]</code>\n        </deckgo-highlight-code>\n<p><br>String.trimStart <br>\n<small>O método trimStart() remove espaços do começo de uma string. trimLeft() é um apelido para este método. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const greeting = &#39;   Hello world!   &#39;;\n\nconsole.log(greeting);\n// expected output: &quot;   Hello world!   &quot;;\n\nconsole.log(greeting.trimStart());\n// expected output: &quot;Hello world!   &quot;;</code>\n        </deckgo-highlight-code>\n<p><br>String.trimEnd <br>\n<small>O método trimEnd() remove espaços do final de uma string. trimRight() é um apelido para este método. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const greeting = &#39;   Hello world!   &#39;;\n\nconsole.log(greeting);\n// expected output: &quot;   Hello world!   &quot;;\n\nconsole.log(greeting.trimEnd());\n// expected output: &quot;   Hello world!&quot;;</code>\n        </deckgo-highlight-code>\n<p><br>Object.fromEntries <br>\n<small>O método Object.fromEntries() transforma uma lista de pares chave-valor em um objeto. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const entries = new Map([\n  [&#39;foo&#39;, &#39;bar&#39;],\n  [&#39;baz&#39;, 42]\n]);\n\nconst obj = Object.fromEntries(entries);\n\nconsole.log(obj);\n// expected output: Object { foo: &quot;bar&quot;, baz: 42 }</code>\n        </deckgo-highlight-code>\n<p><br>Symbol.description <br>\n<small>A propriedade leitura somente description é uma string que retorna a descrição opcional de objetos Symbol. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">console.log(Symbol(&#39;desc&#39;).description);\n// expected output: &quot;desc&quot;\n\nconsole.log(Symbol.iterator.description);\n// expected output: &quot;Symbol.iterator&quot;\n\nconsole.log(Symbol.for(&#39;foo&#39;).description);\n// expected output: &quot;foo&quot;\n\nconsole.log(`${Symbol(&#39;foo&#39;).description}bar`);\n// expected output: &quot;foobar&quot;</code>\n        </deckgo-highlight-code>\n<p><br><br></p>\n<h3>ECMAScript 2020 / ES11</h3> <br>\n<p><br>GlobalThis <br>\n<small>A propriedade global globalThis retorna um objeto global de nível superior. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">var getGlobal = function () {\n  if (typeof self !== &#39;undefined&#39;) { return self; }\n  if (typeof window !== &#39;undefined&#39;) { return window; }\n  if (typeof global !== &#39;undefined&#39;) { return global; }\n  throw new Error(&#39;unable to locate global object&#39;);\n};\n\nvar globals = getGlobal();\n\nif (typeof globals.setTimeout !== &#39;function&#39;) {\n  // sem setTimeout neste ambiente!\n}</code>\n        </deckgo-highlight-code>\n<p><br>Nullish coalescing operator <br>\n<small>O operador de coalescência nula (??) é um operador lógico que retorna o seu operando do lado direito quando o seu operador do lado esquerdo é null ou undefined. Caso contrário, ele retorna o seu operando do lado esquerdo.</p>\n<p>Ao contrário do operador lógico OR (||), o operando esquerdo é retornado se houver um valor falsy (falso) que não seja null ou undefined </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const foo = null ?? &#39;default string&#39;;\nconsole.log(foo);\n// expected output: &quot;default string&quot;\n\nconst baz = 0 ?? 42;\nconsole.log(baz);\n// expected output: 0</code>\n        </deckgo-highlight-code>\n<p><br>Optional chaining operator <br>\n<small>O operador de encadeamento opcional ?. permite a leitura do valor de uma propriedade localizada internamente em uma cadeia de objetos conectados, sem que a validação de cada referência da cadeia seja expressivamente realizada.<br>O operador ?. funciona de maneira similar ao operador . de encadeament, exceto que, ao invés de causar um erro se a referência é nullish (null ou undefined), a expressão sofre um \"curto-circuito\" e retorna com um valor de undefined. Quando utilizado com uma chamada de função, retorna undefined se a função executada não existir.<br>Isso resulta em expressões mais curtas e simples ao acessar propriedades encadeadas quando a possibilidade de uma referência ser inexistente. Isso também pode auxiliar ao explorar o conteúdo de um objeto quando não existe garantia da existência de determinadas propriedades obrigatórias.\n</small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const adventurer = {\n  name: &#39;Alice&#39;,\n  cat: {\n    name: &#39;Dinah&#39;\n  }\n};\n\nconst dogName = adventurer.dog?.name;\nconsole.log(dogName);\n// expected output: undefined\n\nconsole.log(adventurer.someNonExistentMethod?.());\n// expected output: undefined</code>\n        </deckgo-highlight-code>\n<p><br>Dynamic import <br>\n<small>A proposta especifica uma nova palavra-chave sintática, import (), que pode ser chamada dinamicamente a partir do código - e é por isso que também é chamada de \"Importação dinâmica\" </small> <br></p>\n<deckgo-highlight-code language=\"html\"  >\n          <code slot=\"code\">&lt;!DOCTYPE html&gt;\n&lt;meta charset=&quot;utf-8&quot;&gt;\n&lt;title&gt;My library&lt;/title&gt;\n&lt;nav&gt;\n  &lt;a href=&quot;books.html&quot; data-entry-module=&quot;books&quot;&gt;Books&lt;/a&gt;\n  &lt;a href=&quot;movies.html&quot; data-entry-module=&quot;movies&quot;&gt;Movies&lt;/a&gt;\n  &lt;a href=&quot;video-games.html&quot; data-entry-module=&quot;video-games&quot;&gt;Video Games&lt;/a&gt;\n&lt;/nav&gt;\n&lt;main&gt;This is a placeholder for the content that will be loaded on-demand.&lt;/main&gt;\n&lt;script&gt;\n  const main = document.querySelector(&#39;main&#39;);\n  const links = document.querySelectorAll(&#39;nav &gt; a&#39;);\n  for (const link of links) {\n    link.addEventListener(&#39;click&#39;, async (event) =&gt; {\n      event.preventDefault();\n      try {\n        const module = await import(`/${link.dataset.entryModule}.mjs`);\n        // The module exports a function named `loadPageInto`.\n        module.loadPageInto(main);\n      } catch (error) {\n        main.textContent = error.message;\n      }\n    });\n  }\n&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<p><br>New export syntax <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">// Existing in JS\nimport * as MyComponent from &#39;./Component.js&#39;\n\n// Added in ES11\nexport * as MyComponent from &#39;./Component.js&#39;</code>\n        </deckgo-highlight-code>\n<p>Promise.allSettled <br>\n<small>O método Promise.allSettled() retorna uma promessa que é resolvida após todas as promessas dadas serem resolvidas ou rejeitadas, com um array de objetos que descrevem o resultado de cada promessa.<br><br>É tipicamente usado quando você tem múltiplas tarefas assíncronas que não são dependentes das conclusões umas das outras, ou quando você sempre quer ter o resultado de cada promessa.<br><br>Para comparação, a promessa retornada por Promise.all() pode ser mais apropriada para tarefas que dependem umas das outras, ou se você precisa que todas as tarefas sejam rejeitadas quando apenas uma é. </small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const promise1 = Promise.resolve(3);\nconst promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, &#39;foo&#39;));\nconst promises = [promise1, promise2];\n\nPromise.allSettled(promises).\n  then((results) =&gt; results.forEach((result) =&gt; console.log(result.status)));\n\n// expected output:\n// &quot;fulfilled&quot;\n// &quot;rejected&quot;</code>\n        </deckgo-highlight-code>\n<p><br>String.matchAll <br>\n<small>O método matchAll() retorna um iterador de todos os resultados correspondentes a uma string em relação a uma expressão regular, incluindo grupos de captura.</small> <br></p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const regexp = /t(e)(st(\\d?))/g;\nconst str = &#39;test1test2&#39;;\n\nconst array = [...str.matchAll(regexp)];\n\nconsole.log(array[0]);\n// expected output: Array [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]\n\nconsole.log(array[1]);\n// expected output: Array [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;]</code>\n        </deckgo-highlight-code>"}},"pageContext":{"slug":"/alem-do-ES6/"}}}